Fastify Best Practices:

Use Fastify's built-in hooks for request lifecycle management
Implement proper error handling and logging with Fastify's error handling capabilities
Utilize Fastify's plugin architecture for better code organization and reusability
Leverage Fastify's built-in support for async/await for improved performance and readability
Implement proper rate limiting to prevent abuse and ensure fair resource allocation

Drizzle ORM Best Practices:

Use Drizzle's type-safe query builder to improve code quality and prevent SQL injection
Implement proper database migrations using Drizzle's migration tools
Utilize Drizzle's query performance optimization features, such as query caching
Follow Drizzle's best practices for database connection pooling to improve performance and scalability
Implement proper error handling and logging for database operations

Zod Best Practices:

Use Zod for runtime type checking and validation to improve data integrity and security
Implement proper error handling and user feedback for validation errors
Utilize Zod's integration with TypeScript for improved type safety and developer experience
Leverage Zod's schema composition features for reusable and maintainable validation logic
Implement proper testing of Zod schemas to ensure correctness and reliability

Swagger and Swagger UI Best Practices:

Implement proper API documentation using Swagger for improved developer experience and API usability
Utilize Swagger UI for interactive API exploration and testing
Follow Swagger's best practices for organizing and structuring API documentation
Implement proper security measures, such as API key authentication, in Swagger documentation
Regularly update and maintain Swagger documentation to reflect changes in the API

Bcryptjs Best Practices:

Use bcryptjs for secure password hashing to protect user credentials
Implement proper password strength requirements and user feedback
Utilize bcryptjs's built-in salt generation for improved security
Follow best practices for securely storing and comparing hashed passwords
Implement proper error handling and logging for authentication-related operations

Cuid2 Best Practices:

Use cuid2 for generating unique identifiers to improve data integrity and prevent collisions
Implement proper validation and error handling for cuid2-generated IDs
Utilize cuid2's built-in features for generating human-readable IDs when appropriate
Follow best practices for securely storing and transmitting cuid2-generated IDs
Implement proper testing of cuid2-generated IDs to ensure correctness and reliability

General Standards:

Implement proper logging and monitoring for improved observability and debugging
Follow proper code organization and modularization practices for better maintainability
Implement comprehensive testing, including unit tests, integration tests, and end-to-end tests
Utilize version control and follow proper branching and merging practices
Implement proper security measures, such as input validation and sanitization, to prevent common vulnerabilities
